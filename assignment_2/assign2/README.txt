Task A: [Key Derivation Function (KDF)]

The implementation of a key derivation function. The function derives the symmetric
key from a user-defined string (password). Use of the appropriate functions from 
the EVP API and the SHA1 cryptographic hash function, in order to generate the key. The KDF
requires as arguments the password and the desired key size (128 or 256 bits) and generates a
symmetric key of the appropriate size.


Task B: [Data Encryption]

Implementation of a function that provides AES-ECB encryption functionality, using 128-bit 
and 256-bit keys. This function reads the data of an input file and encrypts them using AES-ECB
with the key generated by the KDF described in Task A. Then, it stores the ciphertext to an 
output file. Use of the EVP API in order to develop the encryption functionality.


Task C: [Data Decryption]

Implementation of a function that reads a ciphertext from an input file and decrypts
it with AES-ECB using 128-bit or 256-bit keys, using the EVP API. The key is generated 
using the KDF described in Task A. When the decryption is over, the function stores the 
plaintext in an appropriate output file.


Task D: [Data Signing (CMAC)]

Implementation of a Cipher-based Message Authentication Code (CMAC) generation function, 
using the EVP and CMAC APIs. This function reads the plaintext data from an input file and 
encrypts them using the encryption function (Task B), using the key generated
by the KDF (Task A), and then generates the CMAC. The size of the CMAC is 16 bytes. 
After the ciphertext and the CMAC are generated, it stores the ciphertext concatenated 
with the CMAC in an appropriate output file.


Task E: [Data Verification (CMAC)]

The implementation of a CMAC verification function. This function reads the
ciphertext concatenated with its CMAC from an input file. Then, it separates the ciphertext 
from the CMAC and decrypts the ciphertext. Using the plaintext obtained by the decryption, it
generates its CMAC and compares it to the one that came with the ciphertext. The function
returns TRUE if the CMAC is successfully verified and stores the plaintext in an 
appropriate file. Otherwise, it just returns FALSE.



Task F: [Using the tool]
1) ENCRYPT PASSWORD="TUC2016030032" BITMODE=256
./assign_1 -i encryptme_256.txt -o decryptme_256.txt -p TUC2016030032 -b 256 -e


2) DECRYPT PASSWORD=“hpy414”. BITMODE=128
./assign_1 -i hpy414_decryptme_128.txt -o hpy414_encryptme_128.txt -p hpy414 -b 128 -d


3) SIGN PASSWORD=“hpy414” BITMODE=128
./assign_1 -i signme_128.txt -o verifyme_128.txt -b 128 -p TUC2016030032 -s


4)
**VERIFY PASSWORD=“hpy414” BITMODE=128
./assign_1 -i hpy414_verifyme_128.txt -o verify_result_128.txt -b 128 -p hpy414 -v

Not verified!!


**VERIFY PASSWORD=“hpy414” BITMODE=256
./assign_1 -i hpy414_verifyme_256.txt -o verify_result_256.txt -b 256 -p hpy414 -v

Not verified!!


gcc --version: (Ubuntu 9.3.0-17ubuntu1~20.04)